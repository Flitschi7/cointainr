"""
Frontend handler for serving the SvelteKit frontend from FastAPI.
This module provides a simplified implementation for serving static files
generated by SvelteKit's adapter-static.
"""

import os
import pathlib
import re
from fastapi import FastAPI, Request, Response
from fastapi.responses import FileResponse, JSONResponse, RedirectResponse, HTMLResponse
from fastapi.staticfiles import StaticFiles
import logging

logger = logging.getLogger(__name__)


def setup_frontend(app: FastAPI):
    """
    Set up routes to serve the SvelteKit frontend from FastAPI.

    This function:
    1. Mounts static files from the build directory
    2. Serves the index.html file for SPA routing
    3. Ensures API routes are not intercepted by static file serving
    """
    # Path to the frontend static files (from the Docker build)
    static_dir = pathlib.Path("/app/static")

    # Check if the static directory exists
    if not static_dir.exists():
        # If frontend files don't exist, just return and let API routes work
        logger.warning("Static directory not found at /app/static")
        return

    # Find available JS files for debugging
    if (static_dir / "_app" / "immutable" / "entry").exists():
        js_files = list((static_dir / "_app" / "immutable" / "entry").glob("*.js"))
        js_file_names = [f.name for f in js_files]
        logger.info(f"Available JS entry files: {js_file_names}")

    # Add a middleware to handle redirects for docs and API endpoints
    @app.middleware("http")
    async def handle_redirects(request: Request, call_next):
        path = request.url.path

        # Handle docs redirects
        if path == "/docs" or path == "/redoc":
            return RedirectResponse(url=f"/api{path}")

        # Process the request normally
        response = await call_next(request)

        # If it's a 404 response for an API request, log it
        if response.status_code == 404 and path.startswith("/api/"):
            logger.warning(f"API endpoint not found: {path}")

        return response

    # Mount static assets directory for JS, CSS, and other assets
    # This handles all files in _app directory (immutable assets)
    if (static_dir / "_app").exists():
        app.mount(
            "/_app", StaticFiles(directory=str(static_dir / "_app")), name="static_app"
        )

    # SPA route handler - serve index.html for all non-API and non-static routes
    @app.get("/{full_path:path}")
    async def serve_spa(request: Request, full_path: str):
        # Skip API routes - these should be handled by FastAPI's router
        if full_path.startswith("api"):
            # Let FastAPI continue to the next route handler
            # This should not be reached if API routes are properly registered
            logger.warning(f"API route not handled by router: {full_path}")
            return JSONResponse(status_code=404, content={"detail": "Not Found"})

        # Check if the path exists as a static file
        requested_path = static_dir / full_path
        if requested_path.exists() and requested_path.is_file():
            return FileResponse(str(requested_path))

        # For SPA routing, return the index.html file
        index_path = static_dir / "index.html"
        if index_path.exists():
            # Read the index.html file
            with open(index_path, "r") as f:
                html_content = f.read()

            # Replace hardcoded URLs in the HTML
            base_url = request.base_url.netloc
            html_content = html_content.replace(
                "http://127.0.0.1:8000", f"http://{base_url}"
            )

            # Add a script to intercept fetch requests and fix URL construction
            intercept_script = """
            <script>
                // Save the original fetch function
                const originalFetch = window.fetch;
                
                // Override the fetch function
                window.fetch = function(url, options) {
                    // Check if the URL contains the hardcoded port
                    if (typeof url === 'string' && url.includes('127.0.0.1:8000')) {
                        // Replace the URL with the current host
                        const newUrl = url.replace('http://127.0.0.1:8000', window.location.origin);
                        console.log('Redirecting fetch from', url, 'to', newUrl);
                        return originalFetch(newUrl, options);
                    }
                    
                    // Otherwise, use the original fetch
                    return originalFetch(url, options);
                };
                
                // Also override XMLHttpRequest
                const originalXHROpen = XMLHttpRequest.prototype.open;
                XMLHttpRequest.prototype.open = function(method, url, async, user, password) {
                    let newUrl = url;
                    if (typeof url === 'string' && url.includes('127.0.0.1:8000')) {
                        newUrl = url.replace('http://127.0.0.1:8000', window.location.origin);
                        console.log('Redirecting XHR from', url, 'to', newUrl);
                    }
                    return originalXHROpen.call(this, method, newUrl, async, user, password);
                };
                
                // Override the URL constructor to handle relative URLs
                const originalURL = window.URL;
                window.URL = function(url, base) {
                    // If the URL starts with /api/v1, convert it to an absolute URL
                    if (typeof url === 'string' && url.startsWith('/api/v1')) {
                        url = window.location.origin + url;
                        console.log('Fixed URL construction:', url);
                    }
                    
                    // Call the original URL constructor
                    return new originalURL(url, base);
                };
                window.URL.prototype = originalURL.prototype;
                window.URL.createObjectURL = originalURL.createObjectURL;
                window.URL.revokeObjectURL = originalURL.revokeObjectURL;
                
                // Create a proxy for all API requests
                const apiProxy = {
                    get: async function(path) {
                        try {
                            const response = await fetch(`${window.location.origin}/api/v1/${path}`);
                            return await response.json();
                        } catch (error) {
                            console.error(`Error fetching ${path}:`, error);
                            return { error: true, message: error.message };
                        }
                    }
                };
                
                // Make it globally available
                window.apiProxy = apiProxy;
                
                // API configuration for Cointainr
                window.COINTAINR_API_CONFIG = {
                    // Base URL for API requests
                    apiBaseUrl: window.location.origin + '/api/v1',
                    
                    // Helper function to create API URLs
                    createApiUrl: function(path) {
                        // If path already starts with http:// or https://, return it as is
                        if (path.startsWith('http://') || path.startsWith('https://')) {
                            return path;
                        }
                        
                        // If path starts with a slash, remove it
                        if (path.startsWith('/')) {
                            path = path.substring(1);
                        }
                        
                        // Return the full URL
                        return this.apiBaseUrl + '/' + path;
                    }
                };
                
                // Redirect all API requests to our proxy
                console.log('API request interceptor installed');
            </script>
            """

            # Insert the script before the closing </head> tag
            html_content = html_content.replace("</head>", f"{intercept_script}</head>")

            # Return the modified HTML
            return HTMLResponse(content=html_content)

        # If index.html doesn't exist, return 404
        return JSONResponse(status_code=404, content={"detail": "Not Found"})
